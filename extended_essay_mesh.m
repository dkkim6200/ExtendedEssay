function extended_essay_mesh()  u = linspace (0.0000999, 0.000101, 50);  v = linspace (2.4, 2.6, 50);  z = zeros(numel(u), numel(v));    for i=1:numel(u)    for j=1:numel(v)      z(i, j) = zeta(u(i), v(j));    endfor  endfor    mesh(u, v, z);    xlabel "U";  ylabel "V";  zlabel "Zeta";endfunctionfunction retval = cycloid_x(t)  retval = pi * t - sin(pi * t);endfunctionfunction retval = cycloid_y(t)  retval = 1 - cos(pi * t);endfunction%function [x, y] = bezier(t, P0, P1, P2, P3)%  x = P0(0)(1-t)^3 + P1(0)(1-t)^2 * t + P2(0)(1-t) * t^2 + P3(0) * t^3;%  y = P0(1)(1-t)^3 + P1(1)(1-t)^2 * t + P2(1)(1-t) * t^2 + P3(1) * t^3;%endfunctionfunction retval = bezier(t, P0, P1, P2, P3)  retval = P0 .* (1-t).^3 + 3 .* P1 .* (1-t).^2 .* t + 3 .* P2 .* (1-t) .* t.^2 + P3 .* t.^3;endfunctionfunction retval = epsilon(t, P0, P1, P2, P3) % t is scalar value, and P0~P3 are 2D vector.  Bx = bezier(t, P0(1), P1(1), P2(1), P3(1));  By = bezier(t, P0(2), P1(2), P2(2), P3(2));    retval = sqrt((cycloid_x(t)-Bx).^2 + (cycloid_y(t)-By).^2);endfunctionfunction retval = zeta(u, v) % Using t interval of 0.001  t = 0:0.001:1;  retval = max(epsilon(t, [0, 0], [0, u], [pi - v, 2], [pi, 2]));endfunctionfunction [u, v, minZeta] = approximate(u_start, u_end, v_start, v_end, interval)  minZeta = inf;  u = 0;  v = 0;    for i = u_start:interval:u_end    for j = v_start:interval:v_end      curZeta = zeta(i, j);            if (curZeta < minZeta)        minZeta = curZeta;        u = i;        v = j;      endif    endfor  endforendfunction